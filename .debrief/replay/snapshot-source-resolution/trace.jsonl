{"id":"e0","type":"say","title":"Introduction","narration":"Let's walk through how the new snapshot-based source resolution works. Instead of trying to remap line numbers when files change, we just open the original file content. Line numbers are always correct because the file is frozen."}
{"id":"s1","type":"sectionStart","title":"Source Resolver","narration":""}
{"id":"e1","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":8,"startCol":0,"endLine":12,"endCol":0},"title":"ResolvedSource type","narration":"The resolver returns a ResolvedSource telling you which URI it opened, what kind of source it is, and optionally a warning if it had to fall back."}
{"id":"e2","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":14,"startCol":0,"endLine":19,"endCol":0},"title":"Resolver context","narration":"It takes context about the workspace, the session metadata, the snapshot provider, and an output channel for logging. Everything it needs to try all three sources."}
{"id":"e3","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":31,"startCol":0,"endLine":35,"endCol":0},"title":"Entry point","narration":"The main function takes a file path and the context. First thing it does is normalize backslashes to forward slashes so we get consistent paths across platforms."}
{"id":"e4","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":37,"startCol":0,"endLine":51,"endCol":0},"title":"Git-pinned source","narration":"Priority one: if the session has a pinned commit SHA, we try the git content provider. This builds a debrief-git URI with the commit and file path. If VS Code can't open it, maybe the commit was garbage-collected, we just fall through to the next option."}
{"id":"e5","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":53,"startCol":0,"endLine":69,"endCol":0},"title":"Snapshot source","narration":"Priority two: check if a snapshot exists for this file. We ask the snapshot provider directly, and if it has one, we build a debrief-snapshot URI. Notice the subtle detail on line 60: if we had a commitSha but git failed, we attach a warning so the user knows we're on the fallback path."}
{"id":"e6","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":71,"startCol":0,"endLine":89,"endCol":0},"title":"Workspace fallback","narration":"Last resort: open the actual workspace file. This always comes with a warning because the file may have changed since the trace was recorded. If even this fails, we return null and the handler will log and skip the step."}
{"id":"s1-end","type":"sectionEnd","title":"","narration":""}
{"id":"e7","type":"say","title":"Transition to provider","narration":"So the resolver delegates snapshot lookups to the content provider. Let's see how that works."}
{"id":"s2","type":"sectionStart","title":"Snapshot Content Provider","narration":""}
{"id":"e8","type":"highlightRange","filePath":"src/ui/snapshotContentProvider.ts","range":{"startLine":15,"startCol":0,"endLine":22,"endCol":0},"title":"Class and root management","narration":"The provider implements VS Code's TextDocumentContentProvider interface. It holds a single snapshot root path, set by the engine when a session loads and cleared when it unloads. Simple state management."}
{"id":"e9","type":"highlightRange","filePath":"src/ui/snapshotContentProvider.ts","range":{"startLine":28,"startCol":0,"endLine":45,"endCol":0},"title":"Providing content","narration":"When VS Code asks for content of a debrief-snapshot URI, we strip the leading slash from the path, join it with the snapshot root, and read the file. If there's no root set or the file doesn't exist, we throw, and the caller handles the fallback."}
{"id":"e10","type":"highlightRange","filePath":"src/ui/snapshotContentProvider.ts","range":{"startLine":50,"startCol":0,"endLine":57,"endCol":0},"title":"hasSnapshot check","narration":"The resolver calls this before even trying to open a snapshot URI. It's a synchronous existsSync check. Normalizes backslashes first, then looks for the file on disk."}
{"id":"s2-end","type":"sectionEnd","title":"","narration":""}
{"id":"e11","type":"say","title":"Transition to handler","narration":"Now let's see how the highlight handler actually uses all of this."}
{"id":"s3","type":"sectionStart","title":"Handler Integration","narration":""}
{"id":"e12","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":48,"startCol":0,"endLine":54,"endCol":0},"title":"Calling the resolver","narration":"This is the key change. Instead of building a file path and calling Uri.file, the handler calls openResolvedSource with the event's file path and the session context. One call, all the fallback logic is handled for you."}
{"id":"e13","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":56,"startCol":0,"endLine":69,"endCol":0},"title":"Handling the result","narration":"If the resolver returns null, every source failed and we bail. Otherwise we destructure the document and source info. If there's a warning, say git failed and we fell back to a snapshot, it gets logged."}
{"id":"e14","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":71,"startCol":0,"endLine":77,"endCol":0},"title":"File transition detection","narration":"Notice we're comparing URI strings now, not file system paths. That's important because snapshot and git URIs don't have meaningful fsPaths. The transition animation still works the same way."}
{"id":"e15","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":89,"startCol":0,"endLine":93,"endCol":0},"title":"Line numbers just work","narration":"And here's the payoff. We use event.range directly, no remapping. When the document is a snapshot, the line numbers are guaranteed correct because it's the exact file content from when the trace was recorded. We just clamp to bounds as a safety net."}
{"id":"s3-end","type":"sectionEnd","title":"","narration":""}
{"id":"s4","type":"sectionStart","title":"Snapshot Capture","narration":""}
{"id":"e16","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":11,"startCol":0,"endLine":22,"endCol":0},"title":"Collecting file paths","narration":"The capture function collects every unique filePath from the trace events and normalizes the separators. If no events reference files, it returns early."}
{"id":"e17","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":31,"startCol":0,"endLine":48,"endCol":0},"title":"Writing snapshots","narration":"For each file, it reads from the workspace and writes a copy into the .assets/snapshots directory next to the trace. Directories are created recursively. If a file can't be read, maybe it was deleted, it logs a warning and moves on. No hard failures."}
{"id":"s4-end","type":"sectionEnd","title":"","narration":""}
{"id":"s5","type":"sectionStart","title":"Engine Wiring","narration":""}
{"id":"e18","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":131,"startCol":0,"endLine":142,"endCol":0},"title":"Setting snapshot root on load","narration":"When the engine loads a session, it computes the snapshot root from the trace path and the metadata's snapshotsDir field, falling back to the conventional .assets/snapshots. It hands that root to the content provider. If there's no trace path, snapshots are disabled."}
{"id":"s5-end","type":"sectionEnd","title":"","narration":""}
{"id":"e19","type":"say","title":"Summary","narration":"That's the whole flow. Snapshots are captured on save, the engine sets the root on load, the resolver picks the best source, the provider serves the content, and the handler gets a document with correct line numbers. No heuristics, no guessing."}
