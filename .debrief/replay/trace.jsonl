{"id":"e1","type":"say","title":"Overview","narration":"Let's walk through how Debrief keeps highlights accurate even when your code changes. The idea is simple: freeze the files the author saw, replay against those frozen copies, and never guess where lines moved."}
{"id":"s1","type":"sectionStart","title":"Freezing Files on Save","narration":""}
{"id":"e2","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":11,"startCol":0,"endLine":15,"endCol":0},"title":"captureSnapshots signature","narration":"This function runs whenever a trace is saved. It takes the trace events, workspace root, and trace directory as inputs."}
{"id":"e3","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":17,"startCol":0,"endLine":22,"endCol":0},"title":"Collect unique paths","narration":"We pull every unique filePath from the events and normalize backslashes. This gives us exactly the files referenced in the walkthrough."}
{"id":"e4","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":28,"startCol":0,"endLine":29,"endCol":0},"title":"Output directory","narration":"Snapshots go under dot-assets slash snapshots, right next to the trace file. Keeps everything self-contained."}
{"id":"e5","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":38,"startCol":0,"endLine":42,"endCol":0},"title":"Read and write","narration":"For each file, we read from the workspace and write the copy. Directories are created recursively so nested paths just work."}
{"id":"e6","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":43,"startCol":0,"endLine":47,"endCol":0},"title":"Graceful skip","narration":"If a file can't be read, we log a warning and keep going. One missing file shouldn't break the whole capture."}
{"id":"e7","type":"highlightRange","filePath":"src/trace/snapshotCapture.ts","range":{"startLine":60,"startCol":0,"endLine":63,"endCol":0},"title":"hasExistingSnapshots","narration":"This helper checks whether snapshots already exist for a trace. We use it to decide if we need to backfill when loading older traces."}
{"id":"s1-end","type":"sectionEnd","title":"","narration":""}
{"id":"s2","type":"sectionStart","title":"Serving Snapshots via URI","narration":""}
{"id":"e8","type":"highlightRange","filePath":"src/ui/snapshotContentProvider.ts","range":{"startLine":15,"startCol":0,"endLine":22,"endCol":0},"title":"Provider class","narration":"This is a VS Code TextDocumentContentProvider. It has one mutable field: the snapshot root directory, set when a session loads and cleared when it unloads."}
{"id":"e9","type":"highlightRange","filePath":"src/ui/snapshotContentProvider.ts","range":{"startLine":28,"startCol":0,"endLine":33,"endCol":0},"title":"Guard check","narration":"When VS Code asks for content, we first check that a root is set. If no session is loaded, we throw a clear error instead of silently failing."}
{"id":"e10","type":"highlightRange","filePath":"src/ui/snapshotContentProvider.ts","range":{"startLine":35,"startCol":0,"endLine":44,"endCol":0},"title":"Read and serve","narration":"We strip the leading slash from the URI path, join it with the root, and read the file. If the snapshot is missing, we throw with the exact path we tried."}
{"id":"e11","type":"highlightRange","filePath":"src/ui/snapshotContentProvider.ts","range":{"startLine":50,"startCol":0,"endLine":57,"endCol":0},"title":"hasSnapshot","narration":"The source resolver calls this before trying to open a snapshot URI. It's a quick synchronous check to avoid unnecessary error handling in the hot path."}
{"id":"s2-end","type":"sectionEnd","title":"","narration":""}
{"id":"e12","type":"say","title":"Transition","narration":"Now for the key piece: the resolver that decides which source to open for every step."}
{"id":"s3","type":"sectionStart","title":"Source Resolution Priority","narration":""}
{"id":"e13","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":8,"startCol":0,"endLine":12,"endCol":0},"title":"ResolvedSource type","narration":"Every resolution returns a kind: snapshot, git, or workspace. The optional warning field lets the UI surface degraded states to the user."}
{"id":"e14","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":31,"startCol":0,"endLine":35,"endCol":0},"title":"Entry point","narration":"Both the highlight and open-file handlers call this single function. It replaces the old pattern of each handler building its own file URI."}
{"id":"e15","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":37,"startCol":0,"endLine":44,"endCol":0},"title":"Workspace mode escape hatch","narration":"Before the priority chain runs, we check the user's replaySourceMode setting. If they chose workspace, we skip straight there. This is the escape hatch."}
{"id":"e16","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":46,"startCol":0,"endLine":60,"endCol":0},"title":"Priority 1: Git","narration":"If the trace is pinned to a commit, we try git first. We build a debrief-git URI and ask VS Code to open it. If git show fails, we fall through to snapshot."}
{"id":"e17","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":62,"startCol":0,"endLine":76,"endCol":0},"title":"Priority 2: Snapshot","narration":"If a snapshot exists, we open a debrief-snapshot URI. Notice the warning: if we got here because git failed, we tell the user we fell back."}
{"id":"e18","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":78,"startCol":0,"endLine":79,"endCol":0},"title":"Priority 3: Workspace","narration":"If nothing else is available, we fall through to workspace files. Old traces without snapshots still work, just with a warning."}
{"id":"e19","type":"highlightRange","filePath":"src/replay/sourceResolver.ts","range":{"startLine":82,"startCol":0,"endLine":97,"endCol":0},"title":"Workspace helper","narration":"The workspace helper resolves the path and attaches a context-aware warning. The message differs depending on whether the user chose workspace mode or we fell back to it."}
{"id":"s3-end","type":"sectionEnd","title":"","narration":""}
{"id":"e20","type":"say","title":"Transition","narration":"Now let's see how users interact with all of this through the sidebar."}
{"id":"s4","type":"sectionStart","title":"Sidebar Source Banner","narration":""}
{"id":"e21","type":"highlightRange","filePath":"webview/timeline.js","range":{"startLine":320,"startCol":0,"endLine":324,"endCol":0},"title":"Banner visibility","narration":"The source banner only renders when we have source info and events are loaded. Otherwise it's hidden completely."}
{"id":"e22","type":"highlightRange","filePath":"webview/timeline.js","range":{"startLine":329,"startCol":0,"endLine":332,"endCol":0},"title":"Workspace mode display","narration":"When the user is in workspace mode, we show a warning icon and a button to switch back to authored mode."}
{"id":"e23","type":"highlightRange","filePath":"webview/timeline.js","range":{"startLine":338,"startCol":0,"endLine":342,"endCol":0},"title":"Snapshot display","narration":"For snapshot traces, we show a package icon with two action buttons: Pin to Commit and Diff vs Workspace. These are the key affordances."}
{"id":"e24","type":"highlightRange","filePath":"webview/timeline.js","range":{"startLine":350,"startCol":0,"endLine":358,"endCol":0},"title":"Button wiring","narration":"Each action button just sends a postMessage to the extension. The extension handles the actual logic: running git commands for pin, opening VS Code diff for the diff button."}
{"id":"s4-end","type":"sectionEnd","title":"","narration":""}
{"id":"s5","type":"sectionStart","title":"Pin to Commit","narration":""}
{"id":"e25","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":575,"startCol":0,"endLine":587,"endCol":0},"title":"Guard checks","narration":"The command starts with two guards: is a trace loaded, and is it already pinned? If either fails, we bail with a clear message."}
{"id":"e26","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":590,"startCol":0,"endLine":603,"endCol":0},"title":"Clean tree check","narration":"We run git status porcelain to check if the working tree is clean. Pinning only makes sense when what's on disk matches what's committed."}
{"id":"e27","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":605,"startCol":0,"endLine":614,"endCol":0},"title":"Dirty tree UX","narration":"If the tree is dirty, we explain why and offer to open Source Control. We never block trace creation, only pinning."}
{"id":"e28","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":617,"startCol":0,"endLine":637,"endCol":0},"title":"Write commit SHA","narration":"When the tree is clean, we grab HEAD, update the session metadata with commitSha and profile documentation, then persist to metadata.json."}
{"id":"s5-end","type":"sectionEnd","title":"","narration":""}
{"id":"s6","type":"sectionStart","title":"Diff Authored vs Workspace","narration":""}
{"id":"e29","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":685,"startCol":0,"endLine":697,"endCol":0},"title":"Diff command guards","narration":"The diff command checks that a trace is loaded and the current step has a file. Can't diff a narration-only step."}
{"id":"e30","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":699,"startCol":0,"endLine":708,"endCol":0},"title":"Build diff refs","narration":"We construct a left ref from the authored source, either git colon sha colon path or snapshot colon path. The right side is always the workspace file."}
{"id":"e31","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":710,"startCol":0,"endLine":720,"endCol":0},"title":"Open VS Code diff","narration":"We resolve both refs to URIs and call vscode.diff. The user sees a side-by-side comparison of what the author saw versus what's on disk now."}
{"id":"s6-end","type":"sectionEnd","title":"","narration":""}
{"id":"e32","type":"say","title":"Summary","narration":"That's the complete snapshot system. Files get frozen on save, served through virtual URIs during replay, and the resolver picks the best source automatically. The sidebar banner gives users one-click access to pin, diff, and toggle between authored and workspace views."}
