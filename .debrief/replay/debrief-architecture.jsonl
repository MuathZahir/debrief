{"id":"intro","type":"say","title":"Introduction","narration":"Let's walk through how the Debrief extension works. We'll start with how it boots up, then trace the flow from loading a trace file all the way through to playing audio with synchronized highlights."}
{"id":"s1","type":"sectionStart","title":"Extension Entry Point","narration":""}
{"id":"e1","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":18,"startCol":0,"endLine":20,"endCol":0},"title":"Activation function","narration":"Everything starts in the activate function. This is the standard VS Code extension entry point that runs when the extension loads."}
{"id":"e2","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":35,"startCol":0,"endLine":37,"endCol":0},"title":"Decoration manager","narration":"First, we create the decoration manager. This handles those blue and amber line highlights you see during playback."}
{"id":"e3","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":47,"startCol":0,"endLine":49,"endCol":0},"title":"TTS player","narration":"Then we create the TTS player. This is the workhorse that generates speech via OpenAI and plays it through system audio."}
{"id":"e4","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":51,"startCol":0,"endLine":62,"endCol":0},"title":"Handler context","narration":"The handler context bundles all these dependencies together. Every event handler gets access to this context so it can control decorations, play audio, and navigate files."}
{"id":"e5","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":64,"startCol":0,"endLine":67,"endCol":0},"title":"Replay engine","narration":"Now we create the replay engine itself and wire it into the context. Notice the circular reference here. The context needs the engine, but the engine needs the context. We solve this by setting it after creation."}
{"id":"s1-end","type":"sectionEnd","title":"","narration":""}
{"id":"s2","type":"sectionStart","title":"Loading a Trace","narration":""}
{"id":"e6","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":332,"startCol":0,"endLine":336,"endCol":0},"title":"File picker","narration":"When the user runs the Load Replay command, we show a file picker filtered to JSONL files."}
{"id":"e7","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":345,"startCol":0,"endLine":349,"endCol":0},"title":"Parse trace file","narration":"Once they pick a file, we parse it using our trace parser. This returns the session and any warnings about malformed lines."}
{"id":"e8","type":"highlightRange","filePath":"src/trace/parser.ts","range":{"startLine":17,"startCol":0,"endLine":19,"endCol":0},"title":"Parser entry","narration":"The parser reads the file and splits it into lines. Each line is a separate JSON object."}
{"id":"e9","type":"highlightRange","filePath":"src/trace/parser.ts","range":{"startLine":24,"startCol":0,"endLine":35,"endCol":0},"title":"Parse each line","narration":"We iterate through each line, parsing the JSON. If a line is malformed, we log a warning and skip it rather than failing the whole file. Graceful degradation."}
{"id":"e10","type":"highlightRange","filePath":"src/trace/parser.ts","range":{"startLine":37,"startCol":0,"endLine":45,"endCol":0},"title":"Zod validation","narration":"After parsing, we validate against a Zod schema. This ensures the event has the right structure and types before we try to use it."}
{"id":"e11","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":358,"startCol":0,"endLine":360,"endCol":0},"title":"Load into engine","narration":"Once parsed, we load the session into the engine. This sets up the events array and kicks off TTS pre-generation in the background."}
{"id":"s2-end","type":"sectionEnd","title":"","narration":""}
{"id":"s3","type":"sectionStart","title":"Replay Engine State Machine","narration":""}
{"id":"e12","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":18,"startCol":0,"endLine":22,"endCol":0},"title":"Engine class","narration":"The replay engine is the heart of Debrief. It's a state machine that tracks which step we're on and coordinates all the moving pieces."}
{"id":"e13","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":19,"startCol":0,"endLine":28,"endCol":0},"title":"Core state","narration":"Here's the core state. We track the events array, current index, play state, and some timing-related fields for auto-advance during playback."}
{"id":"e14","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":119,"startCol":0,"endLine":131,"endCol":0},"title":"Load session","narration":"When we load a session, we reset all the state, store the events, and fire the session loaded event. Importantly, we also start pre-generating TTS for all events in the background."}
{"id":"e15","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":177,"startCol":0,"endLine":182,"endCol":0},"title":"Go to step","narration":"The goToStep method is where the magic happens. It validates the index, clears any pending timers, and prepares to execute the step."}
{"id":"e16","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":201,"startCol":0,"endLine":209,"endCol":0},"title":"Execute handler","narration":"We look up the handler for this event type and execute it. The handler does the actual work of opening files, applying highlights, and starting TTS."}
{"id":"e17","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":231,"startCol":0,"endLine":235,"endCol":0},"title":"Auto-advance","narration":"If we're in playing mode, we wait for TTS to complete before advancing. This synchronizes the audio with the step navigation."}
{"id":"s3-end","type":"sectionEnd","title":"","narration":""}
{"id":"s4","type":"sectionStart","title":"Event Handlers","narration":""}
{"id":"e18","type":"highlightRange","filePath":"src/replay/handlers/index.ts","range":{"startLine":12,"startCol":0,"endLine":23,"endCol":0},"title":"Handler context interface","narration":"The handler context interface defines what every handler has access to. Workspace root, decoration manager, TTS player, and the engine itself."}
{"id":"e19","type":"highlightRange","filePath":"src/replay/handlers/index.ts","range":{"startLine":40,"startCol":0,"endLine":47,"endCol":0},"title":"Handler registry","narration":"We register handlers for each event type in this simple lookup table. When the engine needs to execute an event, it just looks up the handler by type."}
{"id":"e20","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":7,"startCol":0,"endLine":8,"endCol":0},"title":"Highlight handler","narration":"The highlight range handler is the most commonly used one. Let's walk through what it does."}
{"id":"e21","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":19,"startCol":0,"endLine":23,"endCol":0},"title":"TTS first pattern","narration":"Notice the TTS-first pattern here. We start the audio immediately, before navigating to the file. This way the user hears the narration while the editor catches up."}
{"id":"e22","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":25,"startCol":0,"endLine":34,"endCol":0},"title":"Follow mode check","narration":"If follow mode is off, we just show a notification instead of navigating. This lets users explore freely while still seeing step info."}
{"id":"e23","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":65,"startCol":0,"endLine":78,"endCol":0},"title":"Open document","narration":"We open the document and show it in the editor. The preview false flag ensures it stays open rather than being replaced by the next file."}
{"id":"e24","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":94,"startCol":0,"endLine":95,"endCol":0},"title":"Apply decorations","narration":"Here's where we apply the visual highlight. The decoration manager handles the animated fade-in effect."}
{"id":"e25","type":"highlightRange","filePath":"src/replay/handlers/highlightRange.ts","range":{"startLine":106,"startCol":0,"endLine":111,"endCol":0},"title":"Scroll into view","narration":"Finally, we scroll the highlighted range into the center of the viewport so the user can see it clearly."}
{"id":"s4-end","type":"sectionEnd","title":"","narration":""}
{"id":"s5","type":"sectionStart","title":"TTS Audio System","narration":""}
{"id":"e26","type":"highlightRange","filePath":"src/audio/ttsPlayer.ts","range":{"startLine":15,"startCol":0,"endLine":24,"endCol":0},"title":"TTS player class","narration":"The TTS player manages audio generation and playback. It caches generated audio to avoid regenerating the same narration twice."}
{"id":"e27","type":"highlightRange","filePath":"src/audio/ttsPlayer.ts","range":{"startLine":78,"startCol":0,"endLine":92,"endCol":0},"title":"Speak async","narration":"speakAsync is the key method. It stops any current audio, increments the request ID for tracking, and fires off generation without blocking."}
{"id":"e28","type":"highlightRange","filePath":"src/audio/ttsPlayer.ts","range":{"startLine":169,"startCol":0,"endLine":177,"endCol":0},"title":"Cache check","narration":"Before generating, we check the cache. If we've already generated audio for this exact text, we skip the API call entirely."}
{"id":"e29","type":"highlightRange","filePath":"src/audio/ttsPlayer.ts","range":{"startLine":291,"startCol":0,"endLine":304,"endCol":0},"title":"OpenAI API call","narration":"For new text, we call the OpenAI TTS API. We use the tts-1-hd model for high quality audio, and the voice is configurable in settings."}
{"id":"e30","type":"highlightRange","filePath":"src/audio/ttsPlayer.ts","range":{"startLine":327,"startCol":0,"endLine":354,"endCol":0},"title":"System playback","narration":"Playback uses native system audio. On Windows we use PowerShell with Media Player, on macOS we use afplay, and on Linux we try mpv first."}
{"id":"e31","type":"highlightRange","filePath":"src/audio/ttsPlayer.ts","range":{"startLine":217,"startCol":0,"endLine":232,"endCol":0},"title":"Stop method","narration":"The stop method kills any running audio process and fires a completion event. This is crucial for cancellation when the user clicks a different step."}
{"id":"s5-end","type":"sectionEnd","title":"","narration":""}
{"id":"s6","type":"sectionStart","title":"Visual Decorations","narration":""}
{"id":"e32","type":"highlightRange","filePath":"src/util/decorations.ts","range":{"startLine":7,"startCol":0,"endLine":11,"endCol":0},"title":"Decoration manager","narration":"The decoration manager handles all the visual highlights in the editor. It keeps track of active decorations so it can clean them up."}
{"id":"e33","type":"highlightRange","filePath":"src/util/decorations.ts","range":{"startLine":24,"startCol":0,"endLine":31,"endCol":0},"title":"Main highlight style","narration":"The main highlight style uses a blue left border and subtle background. The overview ruler color makes it visible in the scrollbar minimap too."}
{"id":"e34","type":"highlightRange","filePath":"src/util/decorations.ts","range":{"startLine":65,"startCol":0,"endLine":72,"endCol":0},"title":"Reference highlights","narration":"Line references get an amber style that stands out from the main blue. These are the specific lines mentioned in the narration."}
{"id":"e35","type":"highlightRange","filePath":"src/util/decorations.ts","range":{"startLine":127,"startCol":0,"endLine":132,"endCol":0},"title":"Animated highlights","narration":"The animation method creates a smooth fade-in effect. It cycles through decoration types with increasing opacity over about 150 milliseconds."}
{"id":"e36","type":"highlightRange","filePath":"src/util/decorations.ts","range":{"startLine":154,"startCol":0,"endLine":167,"endCol":0},"title":"Fade steps","narration":"We create decoration types for each opacity level, then cycle through them with short delays. It's a simple but effective animation."}
{"id":"s6-end","type":"sectionEnd","title":"","narration":""}
{"id":"s7","type":"sectionStart","title":"Tying It All Together","narration":""}
{"id":"e37","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":324,"startCol":0,"endLine":351,"endCol":0},"title":"TTS synchronization","narration":"Here's the synchronization magic. We listen for TTS completion events and only advance to the next step after the audio finishes. This keeps everything in sync."}
{"id":"e38","type":"highlightRange","filePath":"src/replay/engine.ts","range":{"startLine":379,"startCol":0,"endLine":389,"endCol":0},"title":"Auto-advance","narration":"The doAdvance method actually moves to the next step. If we reach the end, it pauses playback automatically."}
{"id":"e39","type":"highlightRange","filePath":"src/extension.ts","range":{"startLine":106,"startCol":0,"endLine":113,"endCol":0},"title":"UI updates","narration":"The engine fires events that the UI listens to. Here the status bar updates whenever the step changes, showing the current position and playback speed."}
{"id":"s7-end","type":"sectionEnd","title":"","narration":""}
{"id":"outro","type":"say","title":"Summary","narration":"That's the core architecture. Trace files get parsed into events, the replay engine manages state and coordinates playback, handlers execute each event type, and TTS keeps everything synchronized with audio narration. The key insight is the TTS-first pattern. Audio starts immediately while navigation happens in parallel, giving a smooth, natural feel."}
