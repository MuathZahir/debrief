{"id":"s1","type":"sectionStart","title":"Bug Fixes Overview","narration":"Let's walk through what we fixed and why these changes matter."}
{"id":"e1","type":"highlightRange","title":"TTS Event-ID Guard","filePath":"src/audio/ttsPlayer.ts","range":{"startLine":84,"startCol":0,"endLine":100,"endCol":0},"narration":"The key insight was that stale handlers could call speakAsync after a new handler already started audio. We added an allowed event ID guard. Now the TTS player only accepts speak calls that match the current step's event ID. Anything else is silently blocked."}
{"id":"e2","type":"highlightRange","title":"Navigation Epoch","filePath":"src/replay/engine.ts","range":{"startLine":186,"startCol":0,"endLine":211,"endCol":0},"narration":"In the engine, each call to goToStep increments a navigation epoch and locks the TTS to the current event. After the handler runs, if the epoch changed, we know someone navigated away during the async work. We just bail out without touching the audio."}
{"id":"e3","type":"highlightRange","title":"Notification Queue","filePath":"src/ui/timelineView.ts","range":{"startLine":68,"startCol":0,"endLine":100,"endCol":0},"narration":"For the notification card, the issue was timing. The sidebar opens, but its JavaScript hasn't loaded yet. Messages sent before the ready handshake are lost. So we queue the notification and deliver it when the webview confirms it's ready."}
{"id":"s1e","type":"sectionEnd","title":"Bug Fixes Overview","narration":""}
{"id":"e4","type":"say","title":"Summary","narration":"Two layers of defense for the audio: the event ID guard prevents stale handlers from starting wrong audio, and the epoch check prevents stale handlers from setting up advance timers. Clean separation of concerns."}
